<?php

namespace AppBundle\Entity;

use AppBundle\Form\Type\ChoiceEditorItemType;
use Doctrine\ORM\Mapping as ORM;

use Symfony\Component\Config\Definition\Exception\Exception;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;

use AppBundle\Form\Type\TextEditorType;
use AppBundle\Form\Type\ChoiceEditorType;

/**
 * @ORM\Entity
 * @ORM\Table(name="survey")
 */
class Survey
{
    /**
     * @var int
     *
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @var string
     *
     * @ORM\Column(type="string")
     */
    private $identifier;

    /**
     * @var string
     *
     * @ORM\Column(type="string")
     */
    private $author;

    /**
     * @var string
     *
     * @ORM\Column(type="string")
     */
    private $title;

    /**
     * @var string
     *
     * @ORM\Column(type="string")
     */
    private $description;

    /**
     * @var array
     *
     * @ORM\Column(type="json_array")
     */
    private $questions;

    /**
     * @var boolean
     *
     * @ORM\Column(type="boolean")
     */
    private $public;

    /**
     * @var boolean
     *
     * @ORM\Column(type="boolean")
     */
    private $closed;

    /**
     * @ORM\Column(type="date")
     */
    private $published;

    /**
     * User constructor
     */
    public function __construct()
    {
        $this->identifier = $this->generateIdentifierHash();
        $this->questions = array();
        $this->closed = 0;
        $this->published = new \DateTime();
    }

    /**
     * getters
     */

    /**
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * @return string
     */
    public function getIdentifier()
    {
        return $this->identifier;
    }

    /**
     * @return mixed
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * @return string
     */
    public function getAuthor()
    {
        return $this->author;
    }

    /**
     * @return array
     */
    public function getQuestions()
    {
        return $this->questions;
    }

    /**
     * @return boolean
     */
    public function isPublic()
    {
        return $this->public;
    }

    /**
     * @return boolean
     */
    public function isClosed()
    {
        return $this->closed;
    }

	/**
	 * @return \DateTime
	 */
    public function getPublished()
    {
        return $this->published;
    }

	/**
	 * @return int
	 */
    public function getTimestamp()
	{
		return $this->published->getTimestamp();
	}

    /**
     * @return array
     */
    public static function getQuestionsTypes()
    {
        return array(
            'textarea', 'text', 'radio', 'checkbox'
        );
    }

	/**
	 * @return array
	 */
	public static function getEditorsTypes()
	{
		return array(
			'textarea', 'text', 'radio', 'checkbox', 'choise_item'
		);
	}

    /**
     * @return array
     */
    public static function getClassesOfTypesQuestions()
    {
        return array(
            TextareaType::class, TextType::class, ChoiceType::class, ChoiceType::class
        );
    }

    /**
     * @return array
     */
    public static function getClassesOfTypesEditors()
    {
        return array(
            TextEditorType::class, TextEditorType::class, ChoiceEditorType::class, ChoiceEditorType::class, ChoiceEditorItemType::class
        );
    }

	/**
	 * @return array
	 */
	public static function getTitlesOfTypesEditors()
	{
		return array(
			'Простой ответ', 'Расширенный ответ', 'Один из многих', 'Многие из многих', 'Вариант ответа'
		);
	}

    /**
     * setters
     */

    /**
     * @param string $title
     * @return object $this
     */
    public function setTitle($title)
    {
        $this->title = $title;

        return $this;
    }

    /**
     * @param string $description
     * @return object $this
     */
    public function setDescription($description)
    {
        $this->description = $description;

        return $this;
    }

    /**
     * @param string $author
     * @return object $this
     */
    public function setAuthor($author)
    {
        $this->author = $author;

        return $this;
    }

    /**
     * @param string $questions
     * @return object $this
     */
    public function setQuestions($questions)
    {
        $this->questions = $questions;

        return $this;
    }

    /**
     * @param boolean $public
     * @return object $this
     */
    public function setPublic($public)
    {
        $this->public = $public;

        return $this;
    }

    /**
     * @param boolean $closed
     * @return object $this
     */
    public function setClosed($closed)
    {
        $this->closed = $closed;

        return $this;
    }

    /**
     * other
     */

	/**
	 * @param $question
	 * @return array
	 */
    public function questionPush($question)
    {
        array_push($this->questions, $question);

        return $this->questions;
    }

	/**
	 * @param $key
	 * @param $question
	 * @return array
	 */
    public function pushQuestion($key, $question)
	{
		// check if exists key
		$this->questions = array_merge($this->questions, [
			$key => $question
		]);

		return $this->questions;
	}

    /**
     * @param $type
     * @return boolean
     */
    public function isAllowedQuestionType($type)
    {
        return in_array($type, $this->getQuestionsTypes());
    }

	/**
	 * @param $type
	 * @return boolean
	 */
	public function isAllowedEditorType($type)
	{
		return in_array($type, $this->getEditorsTypes());
	}

    /**
     * @param $type
     * @return mixed
     */
    public function getQuestionClassByTypeString($type)
    {
        return str_replace(
            $this->getQuestionsTypes(),
            $this->getClassesOfTypesQuestions(),
            $type
        );
    }

    /**
     * @param $type
     * @return mixed
     */
    public function getEditorClassByTypeString($type)
    {
        return str_replace(
            $this->getEditorsTypes(),
            $this->getClassesOfTypesEditors(),
            $type
        );
    }

    /**
     * @param $type
     * @return mixed
     */
    public function getEditorTypeClassByQuestionTypeClass($type)
    {
		$editorTypes = $this->getClassesOfTypesEditors();
		array_pop($editorTypes);

        return str_replace(
            $this->getClassesOfTypesQuestions(),
			$editorTypes,
            $type
        );
    }

	/**
	 * @param $type
	 * @return mixed
	 */
    public function getEditorTypeTitleByQuestionTypeString($type)
	{
		return str_replace(
			$this->getEditorsTypes(),
			$this->getTitlesOfTypesEditors(),
			$type
		);
	}

	/**
	 * @param $type
	 * @return bool
	 */
	public function isExistsQuestionTypeString($type)
	{
		return in_array($type, $this->getQuestionsTypes());
	}

	public function isChoiceType($type)
	{
		return $this->isSelectableType($type);
	}

    /**
     * @return string
     */
    public static function generateIdentifierHash()
    {
        return hash('adler32', 'T:' . time() . 'R:' . random_bytes(array(64, 128, 512)[mt_rand(0,2)]));
    }

	/**
	 * @return string
	 */
    public static function generateKeyHash()
	{
		return hash('adler32', 'T:' . time() . 'R:' . random_bytes(array(64, 128, 512)[mt_rand(0,2)]));
	}

	/**
	 * @return string
	 */
	public static function generateKey()
	{
		return hash('adler32', 'T:' . time() . 'R:' . random_bytes(array(64, 128, 512)[mt_rand(0,2)]));
	}

	/**
	 * @param $key
	 * @return mixed
	 */
	public function getQuestionTypeByKey($key)
	{
		return $this->questions[$key]['type'];
	}

	/**
	 * @param $key
	 * @param $type
	 * @return bool
	public function isQuestionTypeCorrect($key, $type)
	{
		$questionType = $this->getQuestionTypeByKey($key);

		if ($questionType === null) return null;

		return ($type === $questionType);
	}
     * */

	/* v2.0 */

	/**
	 * @return $this
	 */
	public function eraseQuestions()
	{
		$this->questions = array();

		return $this;
	}

	public function isSelectableType($type)
	{
		return in_array($type, [
				'radio', 'checkbox'
			]) || $type == ChoiceType::class;
	}

	public function issetQuestionKey($key)
	{
		return isset($this->questions[$key]);
	}

	/**
	 * @param $key
	 * @return mixed
	 */
	public function getQuestion($key)
	{
		return $this->questions[$key];
	}

	/**
	 * @param $title
	 * @param $type
	 * @param $required
	 * @param array $data
	 * @return string
	 */
	public function addQuestion($title, $type, $required, array $data)
	{
		$key = isset($data['key']) ? $data['key'] : $this->generateKey();

		// check key, if isset - regen

		$this->questions[$key] = [
			'title' => $title,
			'type' => $type,
			'required' => $required
		];

		if ($this->isSelectableType($type) && isset($data['options']))
		{
			$this->addOptionsInSelectableQuestion($key, array_values($data['options']));
		}

		return $key;
	}

	/**
	 * @param $key
	 * @param $option
	 * @return mixed
	 */
	public function addOptionInSelectableQuestion($key, $option)
	{
		$question = $this->getQuestion($key);

		if (isset($question['options']) == FALSE)
		{
			$question['options'] = array();
		}

		$question['options'][$this->generateKey()] = $option;

		$this->questions[$key] = $question;

		return $question;
	}

	/**
	 * @param $key
	 * @param array $options
	 * @return mixed
	 */
	public function addOptionsInSelectableQuestion($key, array $options)
	{
		foreach ($options as $option)
		{
			$this->addOptionInSelectableQuestion($key, $option);
		}

		return $this->getQuestion($key);
	}

	/**
	 * @param $key
	 * @param array $option
	 * @return mixed
	 */
	public function updateOptionInSelectableQuestion($key, array $option)
	{
		$question = $this->getQuestion($key);

		if (isset($question['options']) == FALSE)
		{
			$question['options'] = array();
		}

		$question['options'] = array_merge($question['options'], $option);

		$this->questions[$key] = $question;

		return $question;
	}

	/**
	 * @param $key
	 * @param array $options
	 * @return mixed
	 */
	public function updateOptionsInSelectableQuestion($key, array $options)
	{
		foreach ($options as $option)
		{
			$this->updateOptionInSelectableQuestion($key, $option);
		}

		return $this->getQuestion($key);
	}

	//

    /**
     * @param $type
     * @return mixed
     */
	public function getEditorTitleByQuestionTypeString($type)
	{
		return str_replace(
			$this->getEditorsTypes(),
			$this->getTitlesOfTypesEditors(),
			$type
		);
	}
}